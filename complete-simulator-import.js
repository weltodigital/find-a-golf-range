const { createClient } = require('@supabase/supabase-js')
const fs = require('fs')
const path = require('path')
const https = require('https')

const supabaseUrl = 'https://jiwttpxqvllvkvepjyix.supabase.co'
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imppd3R0cHhxdmxsdmt2ZXBqeWl4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI2OTYzOTYsImV4cCI6MjA3ODI3MjM5Nn0.148Ql7sFERIG3Vc-tXVPcG8kAoNNf9S0yPtZeCNEVZ8'
const supabase = createClient(supabaseUrl, supabaseAnonKey)

// Function to create a slug from a string
function createSlug(str) {
  return str
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '') // Remove special characters except hyphens and spaces
    .replace(/[\s_-]+/g, '-') // Replace spaces, underscores, and multiple hyphens with single hyphen
    .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens
}

// Function to geocode an address using OpenStreetMap Nominatim API
async function geocodeAddress(address, city, retries = 3) {
  return new Promise((resolve) => {
    const query = encodeURIComponent(`${address}, ${city}, UK`)
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${query}&limit=1&countrycodes=gb`

    const req = https.get(url, {
      headers: { 'User-Agent': 'FindAGolfRange/1.0 (contact@example.com)' }
    }, (res) => {
      let data = ''

      res.on('data', (chunk) => data += chunk)
      res.on('end', () => {
        try {
          const results = JSON.parse(data)
          if (results && results.length > 0) {
            resolve({
              lat: parseFloat(results[0].lat),
              lng: parseFloat(results[0].lon)
            })
          } else {
            resolve({ lat: null, lng: null })
          }
        } catch (error) {
          console.error(`Geocoding error for ${address}, ${city}:`, error.message)
          resolve({ lat: null, lng: null })
        }
      })
    })

    req.on('error', (error) => {
      console.error(`Request error for ${address}, ${city}:`, error.message)
      if (retries > 0) {
        console.log(`Retrying geocoding for ${address}, ${city}... (${retries} retries left)`)
        setTimeout(() => {
          geocodeAddress(address, city, retries - 1).then(resolve)
        }, 2000)
      } else {
        resolve({ lat: null, lng: null })
      }
    })

    req.setTimeout(10000, () => {
      req.destroy()
      if (retries > 0) {
        console.log(`Timeout for ${address}, ${city}, retrying... (${retries} retries left)`)
        setTimeout(() => {
          geocodeAddress(address, city, retries - 1).then(resolve)
        }, 2000)
      } else {
        console.error(`Geocoding timeout for ${address}, ${city}`)
        resolve({ lat: null, lng: null })
      }
    })
  })
}

// Function to check if a simulator already exists
async function simulatorExists(name, city) {
  try {
    const { data, error } = await supabase
      .from('golf_ranges')
      .select('id')
      .eq('name', name)
      .eq('city', city)
      .contains('special_features', ['Indoor Simulator'])
      .limit(1)

    if (error) {
      console.error('Error checking if simulator exists:', error)
      return false
    }

    return data && data.length > 0
  } catch (error) {
    console.error('Error checking simulator:', error)
    return false
  }
}

// Function to create city directory pages
async function createCityPages(cities) {
  const basePath = './src/app/simulators/uk'

  for (const city of cities) {
    const citySlug = createSlug(city)
    const cityPath = path.join(basePath, citySlug)

    // Create directory if it doesn't exist
    if (!fs.existsSync(cityPath)) {
      fs.mkdirSync(cityPath, { recursive: true })
      console.log(`Created directory: ${cityPath}`)

      // Create page.tsx for this city (will be generated by the dynamic route)
      // No need to create individual files since we're using [city] dynamic routing
    }
  }
}

async function main() {
  try {
    console.log('Starting complete simulator import process...')

    // Read the valid simulators data
    const simulatorsData = JSON.parse(fs.readFileSync('./valid-simulators.json', 'utf8'))
    console.log(`Found ${simulatorsData.length} simulators to process`)

    // Get unique cities from the data
    const uniqueCities = [...new Set(simulatorsData.map(s => s.city))].filter(Boolean)
    console.log(`Found ${uniqueCities.length} unique cities`)

    let processedCount = 0
    let skippedCount = 0
    let errorCount = 0
    let geocodedCount = 0

    // Process simulators in batches to respect API limits
    const batchSize = 10

    for (let i = 0; i < simulatorsData.length; i += batchSize) {
      const batch = simulatorsData.slice(i, i + batchSize)
      console.log(`\nProcessing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(simulatorsData.length/batchSize)}`)

      for (const simulator of batch) {
        try {
          // Check if simulator already exists
          const exists = await simulatorExists(simulator.name, simulator.city)
          if (exists) {
            console.log(`‚è≠Ô∏è  Skipping ${simulator.name} (${simulator.city}) - already exists`)
            skippedCount++
            continue
          }

          console.log(`üèåÔ∏è  Processing: ${simulator.name} (${simulator.city})`)

          // Geocode the address if we don't have coordinates
          let coordinates = { lat: simulator.latitude, lng: simulator.longitude }
          if (!coordinates.lat || !coordinates.lng) {
            if (simulator.address && simulator.city) {
              console.log(`üìç Geocoding: ${simulator.address}, ${simulator.city}`)
              coordinates = await geocodeAddress(simulator.address, simulator.city)
              if (coordinates.lat && coordinates.lng) {
                geocodedCount++
                console.log(`‚úÖ Geocoded: ${coordinates.lat}, ${coordinates.lng}`)
              }
              // Add delay to respect API limits
              await new Promise(resolve => setTimeout(resolve, 1500))
            }
          }

          // Prepare the data for insertion
          const simulatorRecord = {
            name: simulator.name,
            slug: simulator.slug || createSlug(simulator.name),
            address: simulator.address || '',
            city: simulator.city,
            county: simulator.county || '',
            postcode: simulator.postcode || '',
            phone: simulator.phone || '',
            website: simulator.website || '',
            email: simulator.email || '',
            latitude: coordinates.lat,
            longitude: coordinates.lng,
            description: simulator.description || `Indoor golf simulator in ${simulator.city}`,
            detailed_description: `Experience year-round golf practice at ${simulator.name} in ${simulator.city}. ${simulator.description || 'Professional indoor golf simulator facility with cutting-edge technology.'}`,
            special_features: ['Indoor Simulator'],
            facilities: simulator.facilities || ['Indoor Simulator', 'Practice Facility'],
            num_bays: simulator.num_simulators || 1,
            prices: simulator.pricing ? { hourly: simulator.pricing } : null,
            opening_hours: simulator.opening_hours || null,
            images: [],
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          }

          // Insert into database
          const { data, error } = await supabase
            .from('golf_ranges')
            .insert(simulatorRecord)
            .select('id')

          if (error) {
            console.error(`‚ùå Error inserting ${simulator.name}:`, error.message)
            errorCount++
          } else {
            console.log(`‚úÖ Inserted ${simulator.name} (ID: ${data[0].id})`)
            processedCount++
          }

        } catch (error) {
          console.error(`‚ùå Error processing ${simulator.name}:`, error.message)
          errorCount++
        }
      }

      // Add delay between batches
      if (i + batchSize < simulatorsData.length) {
        console.log('‚è∏Ô∏è  Waiting between batches...')
        await new Promise(resolve => setTimeout(resolve, 3000))
      }
    }

    console.log('\nüìä Import Summary:')
    console.log(`‚úÖ Successfully processed: ${processedCount}`)
    console.log(`‚è≠Ô∏è  Skipped (already exists): ${skippedCount}`)
    console.log(`üìç Geocoded addresses: ${geocodedCount}`)
    console.log(`‚ùå Errors: ${errorCount}`)
    console.log(`üìç Total venues: ${processedCount + skippedCount}`)

    // Create city pages for all unique cities
    console.log('\nüèóÔ∏è  Creating city pages...')
    await createCityPages(uniqueCities)
    console.log('‚úÖ City page structure updated')

    // Write summary to file
    const summary = {
      timestamp: new Date().toISOString(),
      totalProcessed: processedCount,
      totalSkipped: skippedCount,
      totalErrors: errorCount,
      geocodedAddresses: geocodedCount,
      uniqueCities: uniqueCities.length,
      cities: uniqueCities.sort()
    }

    fs.writeFileSync('./complete-import-summary.json', JSON.stringify(summary, null, 2))
    console.log('üìù Summary written to complete-import-summary.json')

    console.log('\nüéâ Complete simulator import finished!')

  } catch (error) {
    console.error('‚ùå Fatal error:', error)
    process.exit(1)
  }
}

main()